*************************************SUB***************************************


-545454512454545.35265454545645 -  -5.352654545456454545645464 =-545454512454539.999999999999995454354536 
54545451245454535265454545645

s21_subTest17 номер теста смо4жешь его найти если что 
    // -545454512454545.35265454545645 exp 14
    src1.bits[0] = 10000010111000100101101011101101; 101100000011111011110000100101001111100111101000001001011010110110000010111000100101101011101101
    src1.bits[1] = 11111001111010000010010110101101;
    src1.bits[2] = 10110000001111101111000010010100;
    src1.bits[3] = 10000000000011100000000000000000;

    // -5.352654545456454545645464 exp 24
    src2.bits[0] = 01001000000110110001111110011000;
    src2.bits[1] = 11111011111111011000100101101101;
    src2.bits[2] = 00000000000001000110110101110111;
    src2.bits[3] = 10000000000110000000000000000000;
    s21_decimal result = {{0, 0, 0, 0}};
    // -54545451245453999999999999999 exp 14
    s21_sub(src1, src2, &result);

должно получится  это 
    // -54545451245453999999999999999 exp 14
    origin.bits[0] =  01001111100110101111111111111111;
    origin.bits[1] =  11111001111001100011111011011011;
    origin.bits[2] =  10110000001111101111000010010100;
    origin.bits[3] =  10000000000011100000000000000000;
конвертировал 
101100000011111011110000100101001111100111100110001111101101101101001111100110101111111111111111
54545451245453999999999999999

а вышло 
01001111100110110000000000000000
11111001111001100011111011011011
10110000001111101111000010010100
1000000000001110 0000000000000000
≠
101100000011111011110000100101001111100111100110001111101101101101001111100110110000000000000000
5454545124545.4000000000000000 exp 14

//---------------------------------------------------------------------------------------------
s21_subTest21
    // src1 = 12345677.987654345678987654346; exp 21
    // src2 = -87654323456.9876545678987653; exp 21
	87666669134.975308913577752954346
	111011011100010011101001100000101001010100011011100001001100110110111101000110000101011101010111000000101010000101100110110
	1110110111000100111010011000001010010101000110111000010011001101101111010001100001010111010
	10111000000101010000101100110110

    src1.bits[0] = 10010001000010101111010011001010;
    src1.bits[1] = 11000000010001011101010111110010;
    src1.bits[2] = 00100111111001000001101100000000;
    src1.bits[3] = 00000000000101010000000000000000;

    src2.bits[0] = 00010001110011011101000110000101;
    src2.bits[1] = 11110101101111000110111111000000;
    src2.bits[2] = 00000010110101010000111100111111;
    src2.bits[3] = 10000000000100000000000000000000;


    origin.bits[0] = 11010010000011011110010110111111;
    origin.bits[1] = 10100111010011100111001000100001;
    origin.bits[2] = 00011100010100111001110111101101;
    origin.bits[3] = 00000000000100010000000000000000; 17

	000111000101001110011101111011011010011101001110011100100010000111010010000011011110010110111111
	8766666913497530891357775295

	а вышло это 

	10010010000001100111100010100101
	10001011011010100100100011011111
	00011100010100011001001100010001
	10000000000100010000000000000000 17

	000111000101000110010011000100011000101101101010010010001101111110010010000001100111100010100101
    8764197777900000022221977765

//---------------------------------------------------------------------------------
START_TEST(s21_subTest28) {
    
    // src1 = 665464545;
    // src2 = 8798232189789785;

    src1.bits[0] = 00100111101010100010111011100001; 665464545
    src1.bits[1] = 00000000000000000000000000000000;
    src1.bits[2] = 00000000000000000000000000000000;
    src1.bits[3] = 00000000000000000000000000000000;

    src2.bits[0] = 00010000010100101110011001011001;  0000000000011111010000011111001000010000010100101110011001011001
    src2.bits[1] = 00000000000111110100000111110010;   8798232189789785
    src2.bits[2] = 00000000000000000000000000000000;
    src2.bits[3] = 00000000000000000000000000000000;
    s21_decimal result = {{0, 0, 0, 0}};
    s21_sub(src1, src2, &result);

    origin.bits[0] = 11101000101010001011011101111000;  11111010000011111000111101000101010001011011101111000
    origin.bits[1] = 00000000000111110100000111110001;   8798231524325240
    origin.bits[2] = 00000000000000000000000000000000;
    origin.bits[3] = 10000000000000000000000000000000;  -

должно получится -8798231524325240
а вышло 

00010111010101110100100010001000
11111111111000001011111000001110
11111111111111111111111111111111   111111111111111111111111111111111111111111100000101111100000111000010111010101110100100010001000
00000000000000000000000000000000



79228162514255539362019625096

//-------------------------------------------------------------------
START_TEST(s21_subTest30) {
    // src1 = -9798956154578676.797564534156;
    // src2 = -2156878451.854764;
	 // рез -9798953997700224.942800534156 
	11111101010011000000100111000 10011110100111100111000100000100 11010010100100100111101010001100

    src1.bits[0] = 01010100010000000011110110001100;
    src1.bits[1] = 10001011010100100000010101011001;
    src1.bits[2] = 00011111101010011000000110101101;
    src1.bits[3] = 10000000000011000000000000000000;

    src2.bits[0] = 01100101111100100100110110101100;
    src2.bits[1] = 00000000000001111010100110101011;
    src2.bits[2] = 00000000000000000000000000000000;
    src2.bits[3] = 10000000000001100000000000000000;
    s21_decimal result = {{0, 0, 0, 0}};
    s21_sub(src1, src2, &result);

    origin.bits[0] = 11010010100100100111101010001100;
    origin.bits[1] = 10011110100111100111000100000100;
    origin.bits[2] = 00011111101010011000000100111000;
    origin.bits[3] = 1000000000001100 0000000000000000; //12

а выдал это 
11010101111011100000000010001100
01111000000001011001100110101101
00011111101010011000001000100010
1000000000001100 0000000000000000  //12


000111111010100110000010001000100111100000000101100110011010110111010101111011100000000010001100
-9798958311457128652328534156
-9798958311457128,652328534156


и тесты на вварианты работы вункции



*************************************ADD***************************************
test_decimal_add_28
    s21_decimal src1 = {{0}};                        -4050669791487,7253402895511700 + 54564654 = -4050615226833.72534028955117
    src1.bits[0] = 10000010111000100101101011101101;100000101110001001011010111011011111100111101000001001011010110110110000001111101111000010010100
    src1.bits[1] = 11111001111010000010010110101101;
    src1.bits[2] = 10110000001111101111000010010100;
    src1.bits[3] = 10000000000011100000000000000000;
    s21_decimal src2 = {{0}};
    src2.bits[0] = 00000011010000001001011100101110;
    src2.bits[1] = 00000000000000000000000000000000;
    src2.bits[2] = 00000000000000000000000000000000;
    src2.bits[3] = 00000000000000000000000000000000;
    s21_decimal original_res = {{0}};
    original_res.bits[0] = 10110000001111100111110100001001; 00000011010000001001011100101110 54564654
    original_res.bits[1] = 01101011000000011011001011110010;
    original_res.bits[2] = 10010111001101000101101011101101;
    original_res.bits[3] = 10000000000100000000000000000000; //16



-5454490559891.4535265454545645

10010100100110011101101011101101
11000101100100110110100101100010
10110000001111101111000110111100
10000000000011100000000000000000

100101001001100111011010111011011100010110010011011010010110001010110000001111101111000110111100 45989780965968558206450856380
1000000000001110 0000000000000000 14


100101001001100111011010111011011100010110010011011010010110001010110000001111101111000110111100
вункция вывела  -4598978096596,8558206450856380

а должно вывести -4050615226833.72534028955117


//---------------------------------------------------------------------------------
START_TEST(s21_test_decimal_add_simple_2) {  // sub

18446744073709551615+4294967295= 18446744078004518910 = 1 00000000000000000000000000000000 11111111111111111111111111111110

    s21_decimal a = {{UINT32_MAX, UINT32_MAX, 0, 0}}; 1111111111111111111111111111111111111111111111111111111111111111 18446744073709551615
    s21_decimal b = {{UINT32_MAX, 0, 0, 0}};
    s21_decimal res = {{0, 0, 0, 0}};
    s21_decimal* p_res = &res;
    s21_add(a, b, p_res);
    s21_decimal c1 = {{11111111111111111111111111111110, 1, 0, 0}};
    ck_assert_int_eq(c1.bits[3], res.bits[3]);
    ck_assert_int_eq(c1.bits[2], res.bits[2]);
    ck_assert_int_eq(c1.bits[1], res.bits[1]);
    ck_assert_int_eq(c1.bits[0], res.bits[0]);
    // show_bit(res);
}
END_TEST

остальные тесты которые не проходя 

































START_TEST(s21_test_decimal_add_simple_2) {  // sub
    s21_decimal a = {{UINT32_MAX, UINT32_MAX, 0, 0}};
    s21_decimal b = {{UINT32_MAX, 0, 0, 0}};
    s21_decimal res = {{0, 0, 0, 0}};
    s21_decimal* p_res = &res;
    s21_add(a, b, p_res);
    s21_decimal c1 = {{11111111111111111111111111111110, 00000000000000000000000000000000, 1, 0}};
    ck_assert_int_eq(c1.bits[3], res.bits[3]);
    ck_assert_int_eq(c1.bits[2], res.bits[2]);
    ck_assert_int_eq(c1.bits[1], res.bits[1]);
    ck_assert_int_eq(c1.bits[0], res.bits[0]);
    // show_bit(res);
}
END_TEST
111111111111111111111111111111111111111111111111111111111111111
9223372036854775807+4294967295 =
1000000000000000000000000000000011111111111111111111111111111110


10000000000000000000000000000000011111111111111111111111111111110
18446744078004518910